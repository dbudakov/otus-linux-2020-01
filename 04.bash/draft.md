### bash  
apropos, type, pack/path - more help
source - start program
шибанг = шапка скрипта
IFS - некий разделитель
set -x в скрипте покажет все команды, нужно при отладке
$-  текущее состояние set
/proc/self/fd
/proc/self/fdinfo
exec
trap 2:20


Альтернативные оболочки: `zsh fish`    
вывод справки: `type help man apropos whatis info`    
`bash -x`   для отладки   
команды `trur/false` - вывод 1 или 0  
 IFS - array знак переноса  
`echo $?` - указывает кол-во ошибок  
`ls -l /dev/std*` - потоки  
`echo $TERM`  
`alias |grep color`  
`tr --help` - замена   
`echo "hello \thonny" \t` - табуляция  
`pipestatus[i]` полезно знать   
`while: exit 0` - не кашерный выход?  
`awk -F\' '$1=="menuentry " {print $2}' /etc/grub2.cfg`    
`sed '/ *#/d; /^ *$/d'`    
`egrep "^#|^$"`  
```shell
rm -rf log{1..999999}         # может не заработать, если 999999 файлов, переполниться стек   
find ./ -name "log*" -delete  # а это нормально работает
```

### Hot keys:   
![alt-текст](https://github.com/dbudakov/4.bash/blob/master/image/moving_bash.png)  
#### move and copy/past   
```
^a ^e - home,end  
Alt+f Alt+b - forward, back  
^w - cut to cursor  
^y - paste  
^u - del string to cursor  
^k - del string after cursor  
```
#### function 
```
Tab или Ctrl+1 - tabulation(bash_completion)  
^j      - Enter  
^l      - clear   
^r      - поиск по строке, повторный Ctrl + r - цикличный поиск по истории   
^r^r    - поиск по последней поисковой строке   
   во время поиска:   
   ^j   - закончить поиск по истории   
   ^g   - закончить поиск и вернуть строку к прежнему состоянию  
^/      - сигнал выхода (SIGQUIT)  
```

#### Перенаправления
```
[file]<< EOF / EOF    
cat << EOF > myscript.sh  
read first second <<< "hello world"   
```
### Scripts
#### варианты запуска  
```
./script.sh (необходим chmod +x)  
bash script.sh  
source script.sh  
```
### Переменные  
```
Для работы с переменными: env printenv export declare 
записaть в /home/user/.bash_profile, экспортных переменных
```
##### Специальные переменные:
```
 $@ — параметры скрипта (столбик)  
 $* - все параметры скрипта (строка)  
 $0 — имя скрипта  
 $# — количество параметров  
 $? — статус выхода последней вýполненной командý  
 $$ — PID оболочки  
 $! — PID последней вýполненной в фоновом режиме командý  
```
##### примеры:  
```
export var=value  
declare var=value  
var=$(expr 3 + 7)  
var1="${var1:-default value}"  
```
### Arrays  
```
files = $(ls) - считýваетсā строка  
array=('first element' 'second element' 'third element')  
array=([3]='fourth element' [4]='fifth element')  
array[0]='first element'  
array[1]='second element'  
echo ${array[2]}  
IFS=$'\n'; echo "${array[*]}"  
declare -A array  
array[first]='First element'  
array[second]='Second element'  
array =(0 1 2)  
```
### Управляющие структуры
####  Условные операторы
##### Оператор варианта case синтаксис:  
`case значени in  
[шаблон].) список1;;  
шаблон2 I шаблонЗ) список2;; ]  
esac  `  
Ищется первый шаблон, совпадающий с значением. Если он найден, то выполняется соответствующий ему список команд, завершенный двумя символами «;». Шаблон и список разделяются символом «)». Одному списку команд может соответствовать несколько шаблонов, тогда они разделяются символом «|».  

##### Условны операто if синтаксис:  
`if список1 ;then  
список2;  
[elif список then  
список4];   
[else  
список5];  
fi;`  
Сначала выполняются команды из списка1. Если этот список выполнен успешно, то есть с кодом завершения 0, то выполняется список2, если нет список, стоящий после очередного elif. При невозможности выполнить список команд, стоящий после очередного then, выполняется список, стоящий после else. Можно использовать сокращенный вариант, только if-then-fi.    
##### Оператор test и условные выражения  
`test -e <файл>     
или  
[ -e <файл> ]`  
`[` — это название команды, а `]` — обязательный последний аргумент этой команды 
``` 
[ -e FILE ] — файл существует  
[ -d FILE ] — это директория  
[ -f FILE ] — это обычный файл  
[ -s FILE ] — размер ненулевой  
[ -r FILE ] — доступен длā чтения  
[ -w FILE ] — доступен для записи  
[ -x FILE ] — исполняемый  
```    
####  Операторы цикла  
##### Оператор цикла с перечислением for:  
`for переменная [in шаблон];  
do  
список;   
done;`
Переменная получает значение первого слова из этого шаблона(списка через пробел), и выполняется список команд, стоящий между do и done. Затем переменная получает значение очередного слова и списка слов, и сново выполняется список команд.  

##### Операто цикл с условие while  
`while список1;  
do  
список2;  
done;`  
Оператор выполняет список1 и в случае его успешного завершения(нулевого кода возврата) — список2. Процедура повторяется до тех пор, пока результ выполнения списка1 не станет ненулевым.   

##### Оператор цикла с инверсным условием until  
`until список1;  
do  
список2;  
done;`  
Оператор выполняет список1 и, если он выполнен неуспешно(код возврата ненулевой), то выполняет список2. Процедура повторяется до тех пор, пока результат выполнения списка1 не станет нулевым.  
##### Операто цикл с выборо select  
`select переменная [in шаблон];  
do  
список;   
done;`   
В результате подстановки шаблона получается список слов. К этим словам оператор добавляет порядковый номер и выводит весь набор в стандартный поток ошибок (stderr).    

[Колисниченко, Аллен: Linux полное руководство](https://proweb.md/ftp/carti/%D0%9A%D0%BE%D0%BB%D0%B8%D1%81%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%BA%D0%BE%20%D0%94%D0%9D%20%20%D0%90%D0%BB%D0%BB%D0%B5%D0%BD%20%D0%9F%D0%B8%D1%82%D0%B5%D1%80%20%D0%92%20Linux%20%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5%20%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE.pdf) Глава 8.  

### Регулярные выражения 
  https://regex101.com/  
  http://ezprompt.net/  
```  
^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$  
  
BRE  
^ - начало строки  
$ - конец строки  
. - любой символ  
\ - экранирование символа  
[A-Z] -диапазоны перечисления  
[xyz] - любой из символов  
[^xyz] - исключенные символы  
* - любое кол-во символов  

ERE - perl/egrep/awk   
{m,n} - сколько раз может встретится символ от - до  
{m} - точное кол-во встречаемости символа  
? - символ может встретится 0 или 1 раз  
+ - любое кол-во символов, но хотя бы 1  
() - группировка символов  
| - какой либо из символов  

Классы
[:alnum:] - A-Za-z0-9  
[:alpha:] - A-Za-z  
[:blank:] пробел или таб  
[:cntrl:] matches control characters  
[:digit:] - 0-9  
[:graph:] графические символý ASCII 33 - 126  
[:lower:] a-z  
[:print:] - [:graph:] + пробел  
[:space:] пробел и таб  
[:upper:] A-Z  
[:xdigit:] hex 0-9A-Fa-f  
```

### Globbing and brace expansion или подстановка  
bash может выполнять подстановку имен файлов. Процесс называется "globbing" при этом используется урезанный набор регулярных выражений  
*, ?, [a-z], {a*,b*}, [^az]  

bash$ ls -l t?.sh  
bash$ ls -l [ab]*  
bash$ ls -l [a-c]*  
bash$ ls -l [^ab]*  
bash$ ls -l {b*,c*,*est*}  
bash$ echo {1..5}{0,5}%  

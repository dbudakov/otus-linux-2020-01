## Домашнее задание  
Работаем с процессами  
Цель: В результате выполнения ДЗ студент запустит скрипт, запускающий два процесса.  
Задания на выбор  
1) написать свою реализацию ps ax используя анализ /proc  
Результат ДЗ - рабочий скрипт который можно запустить  
2) написать свою реализацию lsof  
Результат ДЗ - рабочий скрипт который можно запустить  
3) дописать обработчики сигналов в прилагаемом скрипте, оттестировать, приложить сам скрипт, инструкции по использованию  
Результат ДЗ - рабочий скрипт который можно запустить + инструкция по использованию и лог консоли  
4) реализовать 2 конкурирующих процесса по IO. пробовать запустить с разными ionice  
Результат ДЗ - скрипт запускающий 2 процесса с разными ionice, замеряющий время выполнения и лог консоли  
5) реализовать 2 конкурирующих процесса по CPU. пробовать запустить с разными nice  
Результат ДЗ - скрипт запускающий 2 процесса с разными nice и замеряющий время выполнения и лог консоли  
Критерии оценки: 5 баллов - принято - любой скрипт  
+1 балл - больше одного скрипта  
+2 балла все скрипты  

## Решение  
чистый скрипт лежит [здесь](https://github.com/dbudakov/5.fork/blob/master/scripts/custom_ps.sh)  
значения полей в файле [/proc/pid/stat
](https://web.archive.org/web/20130302063336/http://www.lindevdoc.org/wiki//proc/pid/stat)  
```shell
#!/bin/bash 
#custom `ps ax`

HZ=$(getconf CLK_TCK)                        # значение `герц в секунду` [значение в 10 меньше]
#HZ=$(grep 'CONFIG_HZ=' /boot/config-$(uname -r)|awk -F= '{print $2}')  # значение `герц в секунду` из файла
Sort() {                                     # функция поиска и сортировки PID
 ls /proc|                                    
 grep ^[0-9]|                                # выбираем только строки начинающиеся с цифры
 sort -n                                     # сортируем по возрастанию
}

Name() {                                     # имя процесса
 head -1 -q /proc/$i/sched 2>/dev/null|      # выводим первую строку, без вывода имени файла /proc/[PID]/sched
 sed -e 's/\ (/\ /g'|                        # заменяем знаки " (" на [пробел]
 sed -e 's/,/\ /g'|                          # заменяем запятые на [пробел]
 awk '{print $1}'                            # выводим первое поле
}

state() {                                    # состояние процесса
 grep State /proc/$i/status 2>/dev/null |    # для каждой $i,он же PID, делаем выборку строки сострояния из файла /proc/[PID]/status
 awk '{print $2}'                            # делаем выборку второго поля, что является состоянием процесса
}

Time() {                                         # полное время использования процессора процессом   
 sim() {                                         # в функцию попадают только значения времени                      
 if [ $utime -eq 0 ]                             # если время процесса использования процессора 
  then                                           # равно нулю то заворачиваем и выводи 0:0
  echo "0:0"  
  else                                          
    a=$(echo "scale=10;($utime+$stime+$cutime+$cstime)/$HZ/60"|bc -l|sed 's/^\./0./') # получаем общее время использования процессора и переводим в минуты(изначально значение в количестве герц[герц в секунду])
    d=$(echo $a|cut -d. -f 1) # отрезае значение до точки это минуты времени использования процессора
    f=$(echo "$(echo "($a-$d)*60"|bc|sed 's/^\./0./'|cut -c 1-2)")  # вычитаем из общего времени минуты остается значение секунд в десятичном веди, умножаем на 60 переводя его в секунды, в значениях начинающиющихся с "." меняем "." на 0, отрезаем первые два знака
    if [[ "$f" == *[.]  ]]                   # заворачиваем значения которые заканчиваются на ".", например если это была десятичная дробь пяти с половиной секунд и мы отрезали первые два знака
       then f=$(echo $f|sed 's/\./0/'|rev)   # меняем "."  на 0 и переворачиваем значение через rev, получая читаемый вид
    fi
  echo "$d:$f"                               # выводим значение минут и секунд времени использования процессора
 fi
 }
utime=$(awk '/[0-9]/{print $14}' /proc/$i/stat 2>/dev/null)  # эти параметры снимают показания
stime=$(awk '/[0-9]/{print $15}' /proc/$i/stat 2>/dev/null)  # времени использования процессора
cutime=$(awk '/[0-9]/{print $16}' /proc/$i/stat 2>/dev/null) # ```значения полей можно узнать по ссылке пред скриптом```
cstime=$(awk '/[0-9]/{print $17}' /proc/$i/stat 2>/dev/null) # 
if [ -z $utime ] 2>/dev/null                                 # если строка пустая то помечаем как FALSE
  then echo "FALSE"               
  else        
    if [ $uptime -eq "0" ] 2>/dev/null                       # также помечаем все строки который  
     then echo "0:0"                                         # использовали время процессора близкое 
     else                                                    # к нулю
       k=$(sim)                                              # все остальные процессы пускаем в sim()
       echo $k
    fi
fi
}

Main() {                                                     # функция снятия значений и 
        for i in $(Sort)                                     # записи их в соответствующие массивы
        do                                                   # по всем каждому PID, значения которы
          NAME[i]=$(Name)                                    # выдает функция Sort()
          STATE[i]=$(state)
          TIME[i]=$(Time)
        done
}

Head() {                                                     # шапка вывода и разбивка на таблицу уже готового
        awk 'BEGIN {print "PID STATE NAME UPTIME"}{print}'|  # результата скрипта
        column -t
        }

Show() {                                                                # формирование таблици значений для каждого PID
        for i in $(Sort)                                                # повторно пробегаясь по Sort() выводит значения    
        do                                                              # из массивов
                echo -e "$i\t${STATE[$i]}\t${NAME[$i]}\t${TIME[$i]}"|   
                awk '/[A-Z]/{print $0}'                                 # выборка только строк в которых присутствует  запись состояния в виде одной заглавной буквы
        done|Head                                                       # передача результата на Head()
}

Main  # вызов функций 
Show  # вызов функций 
```

Дополнительная информация:  
kill -l # вывести список сигналов  
kill -0 <PID> # проверяет наличие PID, если процесс есть, код возврата "0"  
strace -e open ps ax - quest calls command  
### Дополнительно
[Move a running process to screen](https://www.linkedin.com/pulse/move-running-process-screen-bruce-werdschinski/)  
